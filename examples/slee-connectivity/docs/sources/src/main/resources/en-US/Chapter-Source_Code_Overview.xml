<?xml version='1.0'?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [<!ENTITY % BOOK_ENTITIES SYSTEM "JAIN_SLEE_Example_User_Guide.ent">%BOOK_ENTITIES;]>

<chapter id="source_code_overview">

	<title>Source Code Overview</title>
	<important>
		<para>
			To obtain the example's complete source code please refer to
			<xref linkend="source_code" />.
		</para>
	</important>
	
	<section id="source_code_overview_sbb">
		<title>Source Code Overview: Sbb</title>
		<note>
			<para>
				For full descirption of
				<acronym>XML</acronym>
				please refer to simpler examples, like sip-wakeup
			</para>
		</note>
		<para><acronym>SBB</acronym> descriptor is very simple. Its only purpose is to define <acronym>SBB</acronym> abstract class and event handler.
		Abstract class is defined as follows:</para>
		<programlisting language="XML" role="XML"><![CDATA[
		<sbb-name>SleeConnectivitySbb</sbb-name>
		<sbb-vendor>org.mobicents</sbb-vendor>
		<sbb-version>1.0</sbb-version>

		<sbb-classes>
			<sbb-abstract-class>
				<sbb-abstract-class-name>
					org.mobicents.slee.service.SleeConnectivitySbb
				</sbb-abstract-class-name>
			</sbb-abstract-class>
		</sbb-classes>
			]]>
			</programlisting>
		
		<para>
		Handler definition looks as follows:</para>
		<programlisting language="XML" role="XML"><![CDATA[
		<event event-direction="Receive" initial-event="True">
			<event-name>CustomEvent</event-name>
			<event-type-ref>
				<event-type-name>org.mobicents.slee.service.connectivity.Event_1</event-type-name>
				<event-type-vendor>org.mobicents</event-type-vendor>
				<event-type-version>1.0</event-type-version>
			</event-type-ref>
			<initial-event-select variable="ActivityContext" />
		</event>
			]]>
			</programlisting>
	</section>
	<section id="source_code_overview_jmx">
		<title>Source Code Overview: JMX Client</title>
		<para><acronym>JMX</acronym> Client is defined by two elements: <acronym>XML</acronym> descriptor and <acronym>POJO</acronym> class.</para>
		<para><acronym>XML</acronym> descriptor is very simple. It looks as follows(<filename>jboss-beans.xml</filename>): </para>
		<programlisting language="XML" role="XML"><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>

<deployment xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns="urn:jboss:bean-deployer:2.0">

	<bean name="SleeConnectionJMXLocal"
		class="org.mobicents.example.slee.connection.SleeConnectionTest">
		<annotation>@org.jboss.aop.microcontainer.aspects.jmx.JMX(
			name="jboss.mobicents:name=JMXAccessTest",exposedInterface=
			org.mobicents.example.slee.connection.SleeConnectionTestMBean.class
				,registerDirectly=true)
		</annotation>
		<!-- 
			<property name="bindAddress">${jboss.bind.address}</property>
			<property name="jnpPort">1099</property>
		 -->
		<property name="bindAddress">${address}</property>
		<property name="jnpPort">${port}</property>
		<property name="transactionManager">
			<inject bean="RealTransactionManager" />
		</property>
		
		<demand>javax.slee.management:name=SleeManagement</demand>
		<demand>RealTransactionManager</demand>
		
	</bean>

</deployment>
		]]>
			</programlisting>
			<para>Descriptor has following elements present: </para>
			<variablelist>
				<varlistentry>
					<term>bean</term>
					<listitem>
						<para> definition of <acronym>POJO</acronym> bean with human readable name and class</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>annotation</term>
					<listitem>
						<para>marks <acronym>POJO</acronym> as <acronym>JMX</acronym> exposed bean</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>property</term>
					<listitem>
						<para>sets value of java bean property with matching name </para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>demand</term>
					<listitem>
						<para>creates requirement - bean with name passed in this tag must be present for declared bean to be deployed</para>
					</listitem>
				</varlistentry>
			</variablelist>
			
			<para>Client contract is defined by implemented interface class, that is <literal>org.mobicents.example.slee.connection.SleeConnectionTestMBean</literal> </para>
			<para>Interface declares two types of methods, parameter accessors and bussines methods.</para>
			<para>Parameter accessors are declared as follows: </para>
			<variablelist>
				<varlistentry>
					<term><literal>public String getBindAddress();</literal></term>
					<listitem>
						<para>Returns address used for remote calls.</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><literal>public void setBindAddress(String bindAddress);</literal></term>
					<listitem>
						<para>Sets address used for remote calls, by default it is equal to local container bind address </para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><literal>public int getJnpPort();</literal></term>
					<listitem>
						<para>Returns port used for remote <acronym>JNP</acronym> calls.</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><literal>public void setJnpPort(int jnpPort);</literal></term>
					<listitem>
						<para>Set port used for remote <acronym>JNP</acronym> calls. Default value is <literal>1099</literal>.</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><literal>public void setTransactionManager(TransactionManager jta);</literal></term>
					<listitem>
						<para>Sets transaction manager.</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><literal>public TransactionManager getTransactionManager();</literal></term>
					<listitem>
						<para>Returns transaction manager.</para>
					</listitem>
				</varlistentry>
				
			</variablelist>
			<para>Bussines methods are declared as follows: </para>
			<note>
				<para>For explanation on <acronym>JTA</acronym> hooks please refer to <acronym>JTA</acronym> <acronym>API</acronym> javadoc contracts. </para>
			</note>
			<variablelist>
				<varlistentry>
					<term>public void fireEventWithRA(String messagePassed);</term>
					<listitem>
						<para>Fires event using localy deployed <acronym>JCA RA</acronym>.  <acronym>RA</acronym> should properly configured to contact remote peer.</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>public void fireEventWithRA_JTA(String messagePassed) throws SystemException, NotSupportedException, IllegalStateException,
			RollbackException, SecurityException, HeuristicMixedException, HeuristicRollbackException;</term>
					<listitem>
						<para>Fires event using localy deployed <acronym>JCA RA</acronym>.  <acronym>RA</acronym> should properly configured to contact remote peer. Event is fired in active <acronym>JTA</acronym> transaction</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>public void fireEventWithRA_JTA_BeforeCompletion(final String messagePassed) throws SystemException, NotSupportedException,
			IllegalStateException, RollbackException, SecurityException, HeuristicMixedException, HeuristicRollbackException;</term>
					<listitem>
						<para>Fires event using localy deployed <acronym>JCA RA</acronym>.  <acronym>RA</acronym> should properly configured to contact remote peer.
						Event is fired using <acronym>JTA</acronym> transaction hook. Event is dispatched on transaction commit, before commit ends.</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>public void fireEventWithRA_JTA_AfterCompletion(final String messagePassed) throws SystemException, NotSupportedException,
			IllegalStateException, RollbackException, SecurityException, HeuristicMixedException, HeuristicRollbackException;</term>
					<listitem>
						<para>As above. Difference is that this method dispatches event on <acronym>JTA</acronym> transaction commit ends.</para>
					</listitem>
				</varlistentry>
				
				<varlistentry>
					<term>public void fireEventWithRemoteSleeService(String messagePassed);</term>
					<listitem>
						<para>Fires event using remote call to <literal>RemoteSleeService</literal>. Remote host for this call is configured with <acronym>JMX</acronym> properties described in this section.</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>public void fireEventWithRemoteSleeService_JTA(String messagePassed) throws SystemException, NotSupportedException, IllegalStateException,
			RollbackException, SecurityException, HeuristicMixedException, HeuristicRollbackException;</term>
					<listitem>
						<para>Fires event using remote call to <literal>RemoteSleeService</literal>. Remote host for this call is configured with <acronym>JMX</acronym> properties described in this section. Event is fired in active <acronym>JTA</acronym> transaction</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>public void fireEventWithRemoteSleeService_JTA_BeforeCompletion(final String messagePassed) throws SystemException, NotSupportedException,
			IllegalStateException, RollbackException, SecurityException, HeuristicMixedException, HeuristicRollbackException;</term>
					<listitem>
						<para>Fires event using remote call to <literal>RemoteSleeService</literal>. Remote host for this call is configured with <acronym>JMX</acronym> properties described in this section.
						Event is fired using <acronym>JTA</acronym> transaction hook. Event is dispatched on transaction commit, before commit ends.</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>public void fireEventWithRemoteSleeService_JTA_AfterCompletion(final String messagePassed) throws SystemException, NotSupportedException,
			IllegalStateException, RollbackException, SecurityException, HeuristicMixedException, HeuristicRollbackException;</term>
					<listitem>
						<para>As above. Difference is that this method dispatches event on <acronym>JTA</acronym> transaction commit ends.</para>
					</listitem>
				</varlistentry>
			</variablelist>
			
			<para>Concrete implementation of described methods can be found in <literal>org.mobicents.example.slee.connection.SleeConnectionTest</literal> class.
			Bussines methods source code is alike, with difference to event fire context. </para>
			<para>&THIS.PLATFORM; <acronym>JCA RA</acronym> can be accessed as follows: </para>
			<programlisting role="JAVA" language="Java">
			
		String eventName = "org.mobicents.slee.service.connectivity.Event_1";
		String eventVendor = "org.mobicents";
		String eventVersion = "1.0";
			
		InitialContext ic = new InitialContext();
		// get reference to JCA RA, it is bound in JNDI, by name: "MobicentsConnectionFactory"
		SleeConnectionFactory factory = (SleeConnectionFactory) ic.lookup("java:/MobicentsConnectionFactory");
		
		SleeConnection conn1 = null;
		//create JCA connection
		conn1 = factory.getConnection();
		
		//create external activity handle to identify activity
		ExternalActivityHandle handle = conn1.createActivityHandle();
		
		//determine eventId
		EventTypeID requestType = conn1.getEventTypeID(eventName, eventVendor, eventVersion);
		//create event instance
		CustomEvent customEvent = new CustomEvent();
		//set message for JSLEE
		customEvent.setMessage(messagePassed);

		//fire event into JSLEE
		conn1.fireEvent(customEvent, requestType, handle, null);
		//close JCA connection, once it wont be used anymore.
		conn1.close();
			</programlisting>
			
		<para>&THIS.PLATFORM; custom <acronym>API</acronym> call is alike <acronym>JCA RA</acronym>, it looks as follows: </para>
			<programlisting role="JAVA" language="Java">
			
		String eventName = "org.mobicents.slee.service.connectivity.Event_1";
		String eventVendor = "org.mobicents";
		String eventVersion = "1.0";
		private String bindAddress = "127.0.0.1";
		private int jnpPort = 1099;
		
		
		//create properties for JNP calls
		Properties props = new Properties();
		props.put(Context.INITIAL_CONTEXT_FACTORY, "org.jnp.interfaces.NamingContextFactory");
		props.put(Context.PROVIDER_URL, "jnp://" + bindAddress + ":" + jnpPort);
		props.put("java.naming.factory.url.pkgs", "org.jboss.naming:org.jnp.interfaces");
		props.put("jnp.disableDiscovery", "true");
			
		InitialContext ic = new InitialContext(props);
		
		//fetch remote slee service, it can be found in public JNDI space.
		RemoteSleeService remoteSleeService = (RemoteSleeService) ic.lookup("/SleeService");
		//create activity handle
		ExternalActivityHandle handle = remoteSleeService.createActivityHandle();
		//determine message ID - unique ID withing SLEE
		EventTypeID requestType = remoteSleeService.getEventTypeID(eventName, eventVendor, eventVersion);
		//create event instance
		CustomEvent customEvent = new CustomEvent();
		customEvent.setMessage(messagePassed);
		//fire event
		remoteSleeService.fireEvent(customEvent, requestType, handle, null);
		//no need to free any resources.
			</programlisting>
	</section>

</chapter>

