<?xml version='1.0'?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "JAIN_SLEE_Example_User_Guide.ent">
%BOOK_ENTITIES;
]>

<section id="registrar_sbb">
	<title>RegistrarSbb</title>
	<para>
		<literal>RegistrarSbb</literal>
		is responsible for handling
		<literal>REGISTER</literal>
		requests and sending proper response.
		<literal>RegistrarSbb</literal>
		receives requests on
		<literal>ActivityContextInterface</literal>
		to which it is attached by its parent, please see
		<xref linkend="proxy_sbb_register" />
		for explanation and code example.
		
	</para>
	<para>Class <literal>org.mobicents.slee.services.sip.registrar.RegistrarSbb</literal> includes all the service logic required to perform registry tasks.</para>
	<section id="registrar_sbb_register_handler">
	<title>Register handler</title>
		<para><literal>RegistrarSbb</literal> operate on <literal>RegistrationBinding</literal>s managed by <literal>LocationService</literal>.</para>
		<para><literal>RegistrarSbb</literal> performs following operations in <literal>REGISTER</literal> event handler:</para>
		<itemizedlist>
			<listitem>
				<para>check if request is a query, if so send response with list of contacts</para>
				<programlisting language="Java" role="JAVA">
	// see if child sbb local object is already in CMP
	LocationSbbLocalObject locationService = getLocationSbb();
				
	// get configuration from MBean
	final long maxExpires=config.getSipRegistrationMaxExpires();
	final long minExpires=config.getSipRegistrationMinExpires();
				
	// Process require header
	
	// Authenticate
	// Authorize
	// OK we're authorized now ;-)
	
	// extract address-of-record
	String sipAddressOfRecord = getCanonicalAddress(
	(HeaderAddress) event.getRequest().getHeader(ToHeader.NAME));
	
	if (logger.isDebugEnabled()) {
	logger.debug("onRegisterEvent: address-of-record from request= " + sipAddressOfRecord);
	}
	
	// map will be empty if user not in LS...
	// Note we don't care if the user has a valid account in the LS, we
	// just add them anyway.
	String sipAddress = getCanonicalAddress((HeaderAddress) event.getRequest()
						.getHeader(ToHeader.NAME));
    Map&lt;String, RegistrationBinding&gt; bindings = locationService
		.getBindings(sipAddress);
	
	// Do we have any contact header(s)?
	if (event.getRequest().getHeader(ContactHeader.NAME) == null) {
	// Just send OK with current bindings - this request was a
	// query.
	logger.info("query for bindings: sipAddress="+sipAddress);
	sendRegistrationOKResponse(event.getServerTransaction(), event.getRequest(), bindings);
	return;
}
				</programlisting>
			</listitem>
			<listitem>
				<para>check if request is remove action, if so remove bindings from data base</para>
				<programlisting language="Java" role="JAVA">
	// Check contact, callid, cseq
				
	ArrayList newContacts = getContactHeaderList(event.getRequest()
						.getHeaders(ContactHeader.NAME));
	final String callId = ((CallIdHeader) event.getRequest()
				.getHeader(CallIdHeader.NAME)).getCallId();
	final long seq = ((CSeqHeader) event.getRequest()
						.getHeader(CSeqHeader.NAME)).getSeqNumber();
	ExpiresHeader expiresHeader = event.getRequest().getExpires();
	
	if (hasWildCard(newContacts)) { // This is a "Contact: *" "remove
		// all bindings" request
		if ((expiresHeader == null)
				|| (expiresHeader.getExpires() != 0)
				|| (newContacts.size() > 1)) {
				// malformed request in RFC3261 ch10.3 step 6
			sendErrorResponse(Response.BAD_REQUEST,
				event.getServerTransaction(),event.getRequest());		
			return;
		}
	
		if (logger.isDebugEnabled()) {
			logger.debug("Removing bindings");
		}
		// Go through list of current bindings
		// if callid doesn't match - remove binding
		// if callid matches and seq greater, remove binding.
		Iterator&lt;RegistrationBinding&gt; it = bindings.values().iterator();
	
		try {
			while (it.hasNext()) {
				RegistrationBinding binding = (RegistrationBinding) it
								.next();
				if (callId.equals(binding.getCallId())) {
					if (seq &gt; binding.getCSeq()) {
						it.remove();
						locationService.removeBinding(sipAddressOfRecord,
											binding.getContactAddress());
					} else {
						sendErrorResponse(Response.BAD_REQUEST,
						event.getServerTransaction(),event.getRequest());
						return;
					}
				} else {
					it.remove();
					locationService.removeBinding(sipAddressOfRecord, binding
							.getContactAddress());
					}
				}
	
			} catch (LocationServiceException lse) {
				logger.error(lse);
				sendErrorResponse(Response.SERVER_INTERNAL_ERROR,
					event.getServerTransaction(),event.getRequest());
				return;
			}
	
		sendRegistrationOKResponse(event.getServerTransaction(), 
			event.getRequest(), bindings);
	}else {
				</programlisting>
			</listitem>
			<listitem>
				<para>check condition for udpate, update bindings, add,remove and send response</para>
				<programlisting language="Java" role="JAVA">
	}else {
		// Update bindings
		if (logger.isDebugEnabled()) {
			logger.debug("Updating bindings");
		}
		ListIterator li = newContacts.listIterator();
	
		while (li.hasNext()) {
			ContactHeader contact = (ContactHeader) li.next();
	
			// get expires value, either in header or default
			// do min-expires etc
			long requestedExpires = 0;
	
			if (contact.getExpires() &gt;= 0) {
				requestedExpires = contact.getExpires();
			} else if ((expiresHeader != null)
				&amp;&amp; (expiresHeader.getExpires() &gt;= 0)) {
				requestedExpires = expiresHeader.getExpires();
			} else {
				requestedExpires = 3600; // default
			}
	
			// If expires too large, reset to our local max
			if (requestedExpires > maxExpires) {
				requestedExpires = maxExpires;
			} else if ((requestedExpires &gt; 0)
				&amp;&amp; (requestedExpires &lt; minExpires)) {
				// requested expiry too short, send response with
				// min-expires
				// 
				sendIntervalTooBriefResponse(event.getServerTransaction(), 
							event.getRequest(), minExpires);
				return;
			}
	
			// Get the q-value (preference) for this binding - default
			// to 0.0 (min)
			float q = 0;
			if (contact.getQValue() != -1)
				q = contact.getQValue();
				if ((q &gt; 1) || (q &lt; 0)) {
					sendErrorResponse(Response.BAD_REQUEST,
							event.getServerTransaction(),event.getRequest());
					return;
				}
	
			// Find existing binding
			String contactAddress = contact.getAddress().getURI().toString();
	
			RegistrationBinding binding = (RegistrationBinding) bindings
								.get(contactAddress);
	
			if (binding != null) { // Update this binding
							
				if (callId.equals(binding.getCallId())) {
					if (seq &lt;= binding.getCSeq()) {
						sendErrorResponse(Response.BAD_REQUEST,
							event.getServerTransaction(),event.getRequest());
						return;
					}
				}
	
				if (requestedExpires == 0) {
					if (logger.isDebugEnabled()) {
						logger.debug("Removing binding: "
							+ sipAddressOfRecord + " -&gt; "
								+ contactAddress);
					}
					bindings.remove(contactAddress);
					locationService.removeBinding(sipAddressOfRecord,
							binding.getContactAddress());
				} else {
					if (logger.isDebugEnabled()) {
						logger.debug("Updating binding: "
							+ sipAddressOfRecord + " -&gt; "
							+ contactAddress);
						logger.debug("contact: " + contact.toString());
					}
					// Lets push it into location service, this will
					// update version of binding
					binding.setCallId(callId);
					binding.setExpires(requestedExpires);
					binding.setRegistrationDate(System.currentTimeMillis());
					binding.setCSeq(seq);
					binding.setQValue(q);
					locationService.updateBinding(binding);
				}
	
			} else {
				// Create new binding
				if (requestedExpires != 0) {
					if (logger.isDebugEnabled()) {
						logger.debug("Adding new binding: "
						+ sipAddressOfRecord + " -&gt; "
						+ contactAddress);
						logger.debug(contact.toString());
				     }
	
				         // removed comment parameter to registration binding
				         // - Address and Contact headers don't have comments
				         // in 1.1
				         RegistrationBinding registrationBinding = locationService
						.addBinding(sipAddress,
							contactAddress, "",
							requestedExpires, System.currentTimeMillis(), q, callId,
							seq);
					   bindings.put(registrationBinding.getContactAddress(), 
								registrationBinding);
	
					}
			}
					}
			// Update bindings, return 200 if successful, 500 on error
			sendRegistrationOKResponse(event.getServerTransaction(), 
				event.getRequest(), bindings);
	}
				</programlisting>
			</listitem>
		</itemizedlist>
		</section>
	<section id="registrar_sbb_child_relation">
	<title>Child relation</title>
	<para><literal>RegistrarSbb</literal> defines <literal>LocationSbb</literal> as child. <literal>LocationSbb</literal> child is
	used as manager for <literal>RegistrationBinding</literal>s. Child relation is declared in sbb-jar.xml descriptor: </para>
	<programlisting language="XML" role="XML"><![CDATA[
 <sbb-jar>
	<sbb id="sip-registrar-sbb">
			<description>JAIN SIP Registrar SBB</description>
			<sbb-name>SipRegistrarSbb</sbb-name>
			<sbb-vendor>org.mobicents</sbb-vendor>
			<sbb-version>1.2</sbb-version>

			<sbb-ref>
				<sbb-name>LocationSbb</sbb-name>
				<sbb-vendor>org.mobicents</sbb-vendor>
				<sbb-version>1.2</sbb-version>
				<sbb-alias>LocationSbb</sbb-alias>
			</sbb-ref>


			<sbb-classes>
				<sbb-abstract-class>
					<sbb-abstract-class-name>
						org.mobicents.slee.services.sip.registrar.RegistrarSbb
					</sbb-abstract-class-name>
					<get-child-relation-method>
						<sbb-alias-ref>LocationSbb</sbb-alias-ref>
						<get-child-relation-method-name>
							getLocationSbbChildRelation
						</get-child-relation-method-name>
						<default-priority>0</default-priority>
					</get-child-relation-method>
				</sbb-abstract-class>
			</sbb-classes>
			
			... 
	</sbb>
</sbb-jar>
		]]>
		</programlisting>
		<para>Parent declaration in descriptor defines method name, in case of example its <literal>getLocationSbbChildRelation</literal>, implented by <acronym>JSLEE</acronym>. This method allows parent to access <literal>javax.slee.ChildRelation</literal> object representing link to defined child.
		<literal>ChildRelation</literal> object gives access to <literal>SbbLocalObject</literal> interface. This object allows parent to:
		 </para>
		 <itemizedlist>
			<listitem><para>attach child to <literal>ActivityContextInterface</literal> to make it eligible to receive events.</para></listitem>
			<listitem><para>invoke synchronously methods defined in child <literal>SbbLocalObject</literal>.</para></listitem> 
		</itemizedlist>
		<para>Its defined in source as follows:</para>
		<programlisting language="Java" role="JAVA">
public abstract class RegistrarSbb implements Sbb {
		
	...
		
	// location service child relation
	public abstract ChildRelation getLocationSbbChildRelation();

	public LocationSbbLocalObject getLocationSbb() throws TransactionRequiredLocalException
		, SLEEException, CreateException {
		return (LocationSbbLocalObject) getLocationSbbChildRelation().create();			
	}
	...
}
		</programlisting>
	</section>
	
	
</section>	